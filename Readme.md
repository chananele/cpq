Installation
============
The installation requires `cmake >= 3.1.0`, `bison >= 3.0.4` and `flex`.

To build the compiler run `cmake path/to/source` from your build directory. 
Next run `cmake --build /path/to/build/directory`.
If you are using MSVC add the parameter `--config Release` (or debug).
Note that in source builds are disabled, you cannot run cmake from the source root.

Usage
=====
To compile a file named *example.cpl* and produce the file *example.qud* run:

    cpq example.cpl example.qud

To read the program from the standard input pass **-** as the first parameter.
Similarly, to write the QUAD program to the standard output pass **-** as the second parameter.

Testing
=======
The tests require `python 2.7` with the `pytest`  and `pathlib2` packages.
To run the test enter the command `ctest`, adding the parameter `-C Release` (or debug) when using MSVC.

The tests are in the *tests* directory in the project root.

In addition to the tests there are several sample inputs in the *inputs* directory in the project root.
The results of running these tests should be appropriate to the code, either an error or correct code.
Specifically, there is a file called *errors.txt* that should demonstrate the compilers ability to detect
more than one error.

Design
======
The compiler's parser uses a LALR parser generated by bison.

Instructions are represented by classes appearing in the *inc/instructions* directory.
These classes are independent of the type on which the instruction operates and uses Label structs
to represent jump targets. The labels are resolved before the final QUAD code is generated.
It similar to backpatching in that there is no need to perform multiple passes but the evaluation
of jump targets is performed by demand.

Statements and expressions (both boolean and regular) are defined in the *inc/statements*, 
*inc/expressions* and *inc/booleans* directories.

All source code to go with definitions is found in the corresponding directory under *src*.

The symbol table is implemented by using cpp's native std::unordered_map which is generally
implemented as a hash table (it has constant time average complexity for most operations).

Several features of bison for type safety and location tracking are used, requiring the high version
of bison.
